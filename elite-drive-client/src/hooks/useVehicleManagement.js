import { useState, useCallback, useEffect, useMemo } from 'react';
import { useVehicles, useAuthCheck, useVehicleOperations } from './useVehicles';
import ReservationService from '@/services/reservationService';

export const useVehicleManagement = () => {
    // Hooks externos
    const { vehicles, loading, error, refetch } = useVehicles();
    const { hasAdminRole, isAuthenticated, loading: authLoading } = useAuthCheck();
    const { createVehicle, updateVehicle, isLoading: operationLoading } = useVehicleOperations();

    // Estados del componente
    const [showForm, setShowForm] = useState(false);
    const [editingVehicle, setEditingVehicle] = useState(null);
    const [searchTerm, setSearchTerm] = useState('');
    const [filterType, setFilterType] = useState('all');
    const [statusFilter, setStatusFilter] = useState('all');
    
    // Estados para reservaciones (usando el mismo patr√≥n que ReservationManagementPage)
    const [reservations, setReservations] = useState([]);
    const [reservationsLoading, setReservationsLoading] = useState(false);
    const [reservationsError, setReservationsError] = useState(null);

    const [reservationDateFrom, setReservationDateFrom] = useState(() => {
        const today = new Date();
        return today.toISOString().split('T')[0]; // YYYY-MM-DD format
    });

    const [reservationDateTo, setReservationDateTo] = useState(() => {
        const today = new Date();
        return today.toISOString().split('T')[0]; // YYYY-MM-DD format
    });

    // Funci√≥n para obtener todas las reservas (igual que en ReservationManagementPage)
    const fetchAllReservations = useCallback(async () => {
        try {
            setReservationsLoading(true);
            setReservationsError(null);
            console.log('üîç Obteniendo todas las reservas...');

            // Usar getAllReservations igual que en ReservationManagementPage
            const reservationsData = await ReservationService.getAllReservations();
            
            // Transformar datos igual que en ReservationManagementPage
            const transformedReservations = reservationsData.map(reservation => ({
                id: reservation.id,
                startDate: reservation.startDate,
                endDate: reservation.endDate,
                totalPrice: reservation.totalPrice,
                status: reservation.status || 'active',
                createdAt: reservation.createdAt || new Date().toISOString(),
                user: {
                    id: reservation.user?.id || reservation.userId,
                    name: reservation.user?.name || 'Usuario no disponible',
                    email: reservation.user?.email || 'email@no-disponible.com',
                    dui: reservation.user?.dui || 'N/A'
                },
                vehicle: {
                    id: reservation.vehicle?.id || reservation.vehicleId,
                    name: reservation.vehicle?.name || 'Veh√≠culo no disponible',
                    brand: reservation.vehicle?.brand || 'N/A',
                    model: reservation.vehicle?.model || 'N/A',
                    type: reservation.vehicle?.vehicleType?.type || reservation.vehicle?.type || 'N/A',
                    capacity: reservation.vehicle?.capacity || 0
                }
            }));

            console.log('üìã Reservas transformadas:', transformedReservations.length);
            setReservations(transformedReservations);

        } catch (err) {
            console.error('‚ùå Error al cargar reservas:', err);
            setReservationsError(err.message || 'Error al cargar las reservas');
            setReservations([]);
        } finally {
            setReservationsLoading(false);
        }
    }, []);

    // Cargar reservas cuando sea necesario
    useEffect(() => {
        if (isAuthenticated && hasAdminRole && !authLoading) {
            fetchAllReservations();
        } else if (!authLoading) {
            setReservationsLoading(false);
        }
    }, [isAuthenticated, hasAdminRole, authLoading, fetchAllReservations]);

    // Filtrar reservas por el rango de fechas especificado
    const reservationsInDateRange = useMemo(() => {
        if (!reservationDateFrom || !reservationDateTo || reservations.length === 0) {
            return [];
        }

        const fromDate = new Date(reservationDateFrom);
        const toDate = new Date(reservationDateTo);
        
        // Establecer horas para comparaci√≥n correcta
        fromDate.setHours(0, 0, 0, 0);
        toDate.setHours(23, 59, 59, 999);

        const filteredReservations = reservations.filter(reservation => {
            // Solo considerar reservas activas/confirmadas
            if (reservation.status?.toLowerCase() !== 'active' && 
                reservation.status?.toLowerCase() !== 'confirmado') {
                return false;
            }

            const startDate = new Date(reservation.startDate);
            const endDate = new Date(reservation.endDate);

            // La reserva est√° activa en el rango si:
            // - Su fecha de inicio es <= toDate Y su fecha de fin es >= fromDate
            return startDate <= toDate && endDate >= fromDate;
        });

        console.log('üóìÔ∏è Reservas en rango de fechas:', {
            fromDate: reservationDateFrom,
            toDate: reservationDateTo,
            totalReservations: reservations.length,
            filteredCount: filteredReservations.length,
            filtered: filteredReservations.map(r => ({
                id: r.id,
                vehicleName: r.vehicle.name,
                vehicleId: r.vehicle.id,
                startDate: r.startDate,
                endDate: r.endDate,
                status: r.status
            }))
        });

        return filteredReservations;
    }, [reservations, reservationDateFrom, reservationDateTo]);

    // Obtener IDs de veh√≠culos reservados en el rango de fechas
    const reservedVehicleIds = useMemo(() => {
        const ids = reservationsInDateRange
            .map(reservation => reservation.vehicle.id)
            .filter(Boolean);
        
        // Eliminar duplicados
        const uniqueIds = [...new Set(ids)];
        
        console.log('üöó IDs de veh√≠culos reservados:', uniqueIds);
        return uniqueIds;
    }, [reservationsInDateRange]);

    // Funci√≥n para obtener veh√≠culos reservados (para compatibilidad)
    const getReservedVehicleIds = useCallback(() => {
        return reservedVehicleIds;
    }, [reservedVehicleIds]);

    // Funci√≥n para determinar el estado efectivo de un veh√≠culo
    const getEffectiveVehicleStatus = useCallback((vehicle) => {
        if (reservedVehicleIds.includes(vehicle.id)) {
            console.log(`‚úÖ Veh√≠culo ${vehicle.name} (ID: ${vehicle.id}) est√° reservado`);
            return 'reserved';
        }
        return vehicle.status || 'maintenanceCompleted';
    }, [reservedVehicleIds]);

    // Filtrar veh√≠culos basado en b√∫squeda y filtro
    const filteredVehicles = useMemo(() => {
        console.log('üîç Filtrando veh√≠culos...');
        console.log('üìä Total veh√≠culos:', vehicles.length);
        console.log('üîç T√©rmino de b√∫squeda:', searchTerm);
        console.log('üè∑Ô∏è Filtro de tipo:', filterType);
        console.log('üìà Filtro de estado:', statusFilter);
        console.log('üöó IDs reservados activos:', reservedVehicleIds);

        const filtered = vehicles.filter(vehicle => {
            // Filtro de b√∫squeda
            const matchesSearch = searchTerm === '' ||
                vehicle.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                vehicle.brand.toLowerCase().includes(searchTerm.toLowerCase()) ||
                vehicle.model.toLowerCase().includes(searchTerm.toLowerCase());

            // Filtro de tipo
            const matchesFilter = filterType === 'all' ||
                vehicle.type?.toLowerCase() === filterType.toLowerCase();

            // Filtro de estado
            let matchesStatus = true;
            if (statusFilter !== 'all') {
                const effectiveStatus = getEffectiveVehicleStatus(vehicle);
                matchesStatus = effectiveStatus === statusFilter;

                if (statusFilter === 'reserved') {
                    console.log(`üéØ Veh√≠culo ${vehicle.name}: effectiveStatus=${effectiveStatus}, matchesStatus=${matchesStatus}`);
                }
            }

            const passes = matchesSearch && matchesFilter && matchesStatus;

            if (statusFilter === 'reserved' && passes) {
                console.log(`‚úÖ Veh√≠culo ${vehicle.name} pasa todos los filtros para 'reserved'`);
            }

            return passes;
        });

        console.log('üìã Veh√≠culos filtrados:', filtered.length);

        if (statusFilter === 'reserved') {
            console.log('üöó Veh√≠culos reservados mostrados:', filtered.map(v => ({
                name: v.name,
                id: v.id,
                effectiveStatus: getEffectiveVehicleStatus(v)
            })));
        }

        return filtered;
    }, [vehicles, searchTerm, filterType, statusFilter, getEffectiveVehicleStatus, reservedVehicleIds]);

    // Obtener tipos √∫nicos para el filtro
    const uniqueTypes = useMemo(() => {
        return [...new Set(vehicles.map(v => v.type).filter(Boolean))];
    }, [vehicles]);

    // Funciones para calcular estad√≠sticas
    const getVehiclesByStatus = useCallback((status) => {
        if (status === 'all') return vehicles;

        return vehicles.filter(vehicle => {
            const effectiveStatus = getEffectiveVehicleStatus(vehicle);
            return effectiveStatus === status;
        });
    }, [vehicles, getEffectiveVehicleStatus]);

    const statusCounts = useMemo(() => {
        const counts = {
            total: vehicles.length,
            reserved: reservedVehicleIds.length,
            underMaintenance: vehicles.filter(v => v.status === 'underMaintenance').length,
            maintenanceRequired: vehicles.filter(v => v.status === 'maintenanceRequired').length,
            outOfService: vehicles.filter(v => v.status === 'outOfService').length,
            maintenanceCompleted: vehicles.filter(v => {
                const effectiveStatus = getEffectiveVehicleStatus(v);
                return effectiveStatus === 'maintenanceCompleted';
            }).length
        };

        console.log('üìä Status counts:', counts);
        return counts;
    }, [vehicles, reservedVehicleIds, getEffectiveVehicleStatus]);

    // Handlers del formulario
    const handleFormSuccess = useCallback(() => {
        setShowForm(false);
        setEditingVehicle(null);
        refetch();
    }, [refetch]);

    const handleAddVehicle = useCallback(() => {
        if (!hasAdminRole) {
            alert('Solo los administradores pueden agregar veh√≠culos');
            return;
        }
        setEditingVehicle(null);
        setShowForm(true);
    }, [hasAdminRole]);

    const handleEditVehicle = useCallback((vehicle, isEditing = true) => {
        if (!hasAdminRole) {
            alert('Solo los administradores pueden editar veh√≠culos');
            return;
        }
        console.log('üîß Editando veh√≠culo:', vehicle.name, 'isEditing:', isEditing);
        setEditingVehicle(vehicle);
        setShowForm(true);
    }, [hasAdminRole]);

    const handleCloseForm = useCallback(() => {
        setShowForm(false);
        setEditingVehicle(null);
    }, []);

    const handleCreateSubmit = useCallback(async (vehicleData) => {
        try {
            await createVehicle(vehicleData, () => {
                handleFormSuccess();
            });
        } catch (error) {
            console.error('Error al crear veh√≠culo:', error);
            // El error ya se maneja en el hook
        }
    }, [createVehicle, handleFormSuccess]);

    const handleUpdateSubmit = useCallback(async (vehicleId, updateData) => {
        try {
            await updateVehicle(vehicleId, updateData, () => {
                handleFormSuccess();
            });
        } catch (error) {
            console.error('Error al actualizar veh√≠culo:', error);
            // El error ya se maneja en el hook
        }
    }, [updateVehicle, handleFormSuccess]);

    const handleRefresh = useCallback(() => {
        console.log('üîÑ Refrescando datos...');
        refetch();
        // Tambi√©n refrescar las reservaciones
        fetchAllReservations();
    }, [refetch, fetchAllReservations]);

    const handleStatusFilterClick = useCallback((status) => {
        console.log('üîÑ Cambiando filtro de estado a:', status);
        setStatusFilter(status);
        // Limpiar otros filtros para mostrar solo por estado
        setSearchTerm('');
        setFilterType('all');
    }, []);

    // Handlers para los filtros de fecha
    const handleReservationDateFromChange = useCallback((date) => {
        console.log('üìÖ Cambiando fecha desde:', date);
        setReservationDateFrom(date);
    }, []);

    const handleReservationDateToChange = useCallback((date) => {
        console.log('üìÖ Cambiando fecha hasta:', date);
        setReservationDateTo(date);
    }, []);

    return {
        // Estados principales
        vehicles,
        loading: loading || reservationsLoading,
        error: error || reservationsError,
        authLoading,
        hasAdminRole,
        isAuthenticated,
        operationLoading,
        showForm,
        editingVehicle,
        searchTerm,
        filterType,
        statusFilter,
        
        // Estados de reservaciones
        reservations,
        reservationsLoading,
        reservationsError,
        reservationDateFrom,
        reservationDateTo,
        reservationsInDateRange, // Nuevo: reservas en el rango de fechas
        
        // Datos computados
        filteredVehicles,
        uniqueTypes,
        statusCounts,
        isEditingMode: !!editingVehicle,

        // Funciones de utilidad
        getReservedVehicleIds,
        getEffectiveVehicleStatus,
        getVehiclesByStatus,

        // Handlers del formulario
        handleFormSuccess,
        handleAddVehicle,
        handleEditVehicle,
        handleCloseForm,
        handleCreateSubmit,
        handleUpdateSubmit,
        handleRefresh,
        handleStatusFilterClick,

        // Handlers de filtros de fecha
        handleReservationDateFromChange,
        handleReservationDateToChange,
        setReservationDateFrom,
        setReservationDateTo,

        // Funciones de filtro
        setSearchTerm,
        setFilterType,
        setStatusFilter
    };
};